---
layout: posts
title:  "Probabilistic Interpretation of the Griffin-Lim Algorithm"
date:   2021-08-30 00:01:00 +0000
categories: python
entries_layout: grid
---

This is a draft post, maths needs to be written up. Here, I provide an interpretation of the Griffin-Lim algorithm as a zero-mean degenerate complex normal distribution. The GLA loss corresponds to the likelihood ignoring constants that don't depend on the STFT.

<details open>
<summary> Code </summary>

{% highlight python %}

import numpy as np
from scipy.linalg import dft

np.random.seed(42)

n = 8
n_fft = 4
hop_length = 2
D = dft(n_fft)
n_frames = n//hop_length - 1

x = np.random.normal(size=n).reshape(-1, 1)

Dk = np.kron(np.eye(n_frames), D/n_fft**0.5)
Dhk = np.kron(np.eye(n_frames), D.T.conj()/n_fft**0.5)

W = np.zeros((n, n_frames))
for i in range(n_frames):
    W[(i*hop_length):(i*hop_length + n_fft), i] = 1

W /= (W @ np.ones((3, 1)))

W_i = np.zeros((n, n_frames*n_fft))
for i in range(n_frames):
    idx_min, idx_max = i*hop_length, i*hop_length + n_fft
    W_i[idx_min:idx_max, (i*n_fft):((i + 1)*n_fft)] = np.diag(W[idx_min:idx_max, i])

W = np.ceil(W_i.T)

def stft(x):
    return Dk @ W @ x

def istft(stft_matrix):
    return W_i @ (Dhk @ S).real

S = stft(x)
# np.abs(istft(S) - x).max()

A = 0.5 * Dk @ W @ W_i @ Dk
B = (0.5 * Dk @ W @ W_i @ Dhk) - np.eye(len(S))

P_inv = (A.T @ A.conj()) + (B.conj().T @ B)
P_inv = -P_inv.conj()
P = np.linalg.inv(P_inv)

R = (2 * B.conj().T @ A @ P).conj().T

# verify R is correct
(0.5*R.T @ P_inv.conj()) - (A.conj().T @ B) # it is - all zeros

R = R.round(10)
P = P.round(10)
P_inv = P_inv.round(10)

# tests

S = np.abs(S)
theta = np.random.uniform(-np.pi, np.pi, size=(n_fft, n_frames))
theta[0, :] = 0
theta[3, :] = -theta[1, :]
S = S * np.exp(theta * 1j).reshape(-1, 1, order='F')

# (-S.conj().T @ P_inv.conj() @ S).real + (S.T @ R.T @ P_inv.conj() @ S).real - \
#     (np.abs(A @ S.conj() + B @ S)**2).sum()

# (A @ S.conj() + B @ S - stft(istft(S)) + S).round(10)

# from librosa import stft as stft_l, istft as istft_l
# S_cut = S.reshape(n_fft, n_frames, order='F')[:3, :]

# (stft_l(istft_l(S_cut, window='boxcar', hop_length=hop_length, center=False), \
#     n_fft=n_fft, window='boxcar', hop_length=hop_length, center=False) - S_cut).round(3) \
#     - (stft(istft(S).reshape(-1, 1)) - S).reshape(n_fft, n_frames, order='F').round(3)[:3, :]

{% endhighlight %}

</details> <br>
